<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translation Speaker - OpenAI TTS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .button-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .button-small {
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-label {
            color: #666;
            font-size: 1em;
        }

        .speakers-list {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .speaker-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .speaker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .speaker-id {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .speaker-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
        }

        .status-running {
            background: #d4edda;
            color: #155724;
        }

        .status-stopped {
            background: #f8d7da;
            color: #721c24;
        }

        .speaker-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .speaker-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .results-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .result-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #28a745;
        }

        .result-item.error {
            border-left-color: #dc3545;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .result-time {
            color: #666;
            font-size: 0.9em;
        }

        .result-text {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #333;
            line-height: 1.6;
        }

        .audio-player {
            margin-top: 10px;
        }

        audio {
            width: 100%;
            height: 40px;
        }

        .result-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }

        .logs-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .log-item {
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-info { background: #d1ecf1; color: #0c5460; }
        .log-success { background: #d4edda; color: #155724; }
        .log-warning { background: #fff3cd; color: #856404; }
        .log-error { background: #f8d7da; color: #721c24; }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #28a745;
            box-shadow: 0 0 10px #28a745;
        }

        .status-disconnected {
            background: #dc3545;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        @media (max-width: 768px) {
            .stats {
                grid-template-columns: 1fr;
            }

            .speaker-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîä Translation Speaker</h1>
            <p class="subtitle">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–æ–≤ —á–µ—Ä–µ–∑ OpenAI TTS</p>
            <div style="margin-top: 15px;">
                <span class="status-indicator" id="wsStatus"></span>
                <span id="wsStatusText">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</span>
            </div>
        </div>

        <div class="controls">
            <div class="section-title">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π Speaker</div>

            <div class="form-group">
                <label for="translatorSelect">Translator (–∏—Å—Ç–æ—á–Ω–∏–∫ –ø–µ—Ä–µ–≤–æ–¥–æ–≤):</label>
                <select id="translatorSelect">
                    <option value="">–ó–∞–≥—Ä—É–∑–∫–∞...</option>
                </select>
            </div>

            <div class="settings-grid">
                <div class="form-group">
                    <label for="voiceSelect">–ì–æ–ª–æ—Å:</label>
                    <select id="voiceSelect">
                        <option value="alloy">Alloy</option>
                        <option value="echo">Echo</option>
                        <option value="fable">Fable</option>
                        <option value="onyx">Onyx</option>
                        <option value="nova">Nova</option>
                        <option value="shimmer">Shimmer</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="modelSelect">–ú–æ–¥–µ–ª—å:</label>
                    <select id="modelSelect">
                        <option value="tts-1">TTS-1 (–±—ã—Å—Ç—Ä–∞—è)</option>
                        <option value="tts-1-hd">TTS-1-HD (–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="speedInput">–°–∫–æ—Ä–æ—Å—Ç—å (0.25 - 4.0):</label>
                    <input type="number" id="speedInput" min="0.25" max="4.0" step="0.25" value="2.0">
                </div>

                <div class="form-group">
                    <label>
                        <input type="checkbox" id="autoSpeakCheck" checked>
                        –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ
                    </label>
                </div>
            </div>

            <button class="button" id="createSpeakerBtn" onclick="createSpeaker()">
                –°–æ–∑–¥–∞—Ç—å Speaker
            </button>
        </div>

        <div class="speakers-list">
            <div class="section-title">–ê–∫—Ç–∏–≤–Ω—ã–µ Speakers</div>
            <div id="speakersList">
                <div class="empty-state">
                    <div class="empty-state-icon">üîä</div>
                    <p>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö speakers. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π speaker –≤—ã—à–µ.</p>
                </div>
            </div>
        </div>

        <div class="stats" id="statsContainer" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="statSpeechCompleted">0</div>
                <div class="stat-label">–û–∑–≤—É—á–µ–Ω–æ</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statSpeechFailed">0</div>
                <div class="stat-label">–û—à–∏–±–æ–∫</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statTotalCharacters">0</div>
                <div class="stat-label">–°–∏–º–≤–æ–ª–æ–≤</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statQueueLength">0</div>
                <div class="stat-label">–í –æ—á–µ—Ä–µ–¥–∏</div>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <div class="section-title">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è</div>
            <div id="resultsList"></div>
        </div>

        <div class="logs-section" id="logsSection" style="display: none;">
            <div class="section-title">–õ–æ–≥–∏</div>
            <div id="logsList"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let currentSpeakerId = null;
        let speakers = new Map();

        // WebSocket connection
        function connectWebSocket(speakerId) {
            if (ws) {
                ws.close();
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/speaker?id=${speakerId}`;

            ws = new WebSocket(wsUrl);
            currentSpeakerId = speakerId;

            ws.onopen = () => {
                updateConnectionStatus(true);
                console.log('WebSocket connected');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };

            ws.onclose = () => {
                updateConnectionStatus(false);
                console.log('WebSocket disconnected');
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (currentSpeakerId) {
                        connectWebSocket(currentSpeakerId);
                    }
                }, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
            };
        }

        function handleWebSocketMessage(msg) {
            console.log('WebSocket message:', msg);

            if (msg.type === 'initial_data') {
                // Server sends data wrapped in data.data
                updateStats(msg.data.stats);
                updateResults(msg.data.results);
                updateLogs(msg.data.logs);
            } else if (msg.type === 'audio_start') {
                speakerAudio.start(msg.data);
            } else if (msg.type === 'audio_chunk') {
                speakerAudio.appendChunk(msg.data);
            } else if (msg.type === 'audio_end') {
                speakerAudio.end(msg.data);
            } else if (msg.type === 'speech_completed') {
                addResult(msg.data);
                if (msg.data.stats) {
                    updateStats(msg.data.stats);
                }
            } else if (msg.type === 'log') {
                addLog(msg.data);
            } else if (msg.type === 'stats_update') {
                updateStats(msg.data);
            }
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('wsStatus');
            const text = document.getElementById('wsStatusText');

            if (connected) {
                indicator.className = 'status-indicator status-connected';
                text.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ';
            } else {
                indicator.className = 'status-indicator status-disconnected';
                text.textContent = '–û—Ç–∫–ª—é—á–µ–Ω–æ';
            }
        }

        // Load translators
        async function loadTranslators() {
            try {
                const response = await fetch('/api/translator');
                const data = await response.json();

                const select = document.getElementById('translatorSelect');
                select.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ translator</option>';

                // data is an array of translators
                data.forEach(translator => {
                    const option = document.createElement('option');
                    option.value = translator.id;
                    option.textContent = `${translator.id} (${translator.status})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load translators:', error);
            }
        }

        // Load speakers
        async function loadSpeakers() {
            try {
                const response = await fetch('/api/speaker');
                const data = await response.json();

                speakers.clear();
                // data is an array of speakers
                data.forEach(speaker => {
                    speakers.set(speaker.id, speaker);
                });

                renderSpeakers();
            } catch (error) {
                console.error('Failed to load speakers:', error);
            }
        }

        function renderSpeakers() {
            const container = document.getElementById('speakersList');

            if (speakers.size === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîä</div>
                        <p>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö speakers. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π speaker –≤—ã—à–µ.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';
            speakers.forEach((speaker, id) => {
                const speakerEl = document.createElement('div');
                speakerEl.className = 'speaker-item';
                speakerEl.innerHTML = `
                    <div class="speaker-header">
                        <div class="speaker-id">${id}</div>
                        <span class="speaker-status ${speaker.isRunning ? 'status-running' : 'status-stopped'}">
                            ${speaker.isRunning ? '–†–∞–±–æ—Ç–∞–µ—Ç' : '–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}
                        </span>
                    </div>
                    <div class="speaker-info">
                        <div><strong>Translator:</strong> ${speaker.translatorId}</div>
                        <div><strong>–ì–æ–ª–æ—Å:</strong> ${speaker.voice}</div>
                        <div><strong>–ú–æ–¥–µ–ª—å:</strong> ${speaker.model}</div>
                        <div><strong>–°–∫–æ—Ä–æ—Å—Ç—å:</strong> ${speaker.speed}x</div>
                        <div><strong>–û–∑–≤—É—á–µ–Ω–æ:</strong> ${speaker.stats.speechCompleted}</div>
                        <div><strong>–í –æ—á–µ—Ä–µ–¥–∏:</strong> ${speaker.stats.queueLength}</div>
                    </div>
                    <div class="speaker-actions">
                        <button class="button button-small" onclick="viewSpeaker('${id}')">
                            –û—Ç–∫—Ä—ã—Ç—å
                        </button>
                        ${speaker.isRunning ?
                            `<button class="button button-small button-danger" onclick="stopSpeaker('${id}')">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>` :
                            `<button class="button button-small" onclick="startSpeaker('${id}')">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>`
                        }
                        <button class="button button-small button-danger" onclick="deleteSpeaker('${id}')">
                            –£–¥–∞–ª–∏—Ç—å
                        </button>
                    </div>
                `;
                container.appendChild(speakerEl);
            });
        }

        // Create speaker
        async function createSpeaker() {
            const translatorId = document.getElementById('translatorSelect').value;
            const voice = document.getElementById('voiceSelect').value;
            const model = document.getElementById('modelSelect').value;
            const speed = parseFloat(document.getElementById('speedInput').value);
            const autoSpeak = document.getElementById('autoSpeakCheck').checked;

            if (!translatorId) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ translator');
                return;
            }

            const btn = document.getElementById('createSpeakerBtn');
            btn.disabled = true;
            btn.textContent = '–°–æ–∑–¥–∞–Ω–∏–µ...';

            try {
                const response = await fetch('/api/speaker', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        translatorId,
                        voice,
                        model,
                        speed,
                        autoSpeak
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    alert('Speaker —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ!');
                    await loadSpeakers();
                    viewSpeaker(data.id);
                } else {
                    alert(`–û—à–∏–±–∫–∞: ${data.error}`);
                }
            } catch (error) {
                console.error('Failed to create speaker:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ speaker');
            } finally {
                btn.disabled = false;
                btn.textContent = '–°–æ–∑–¥–∞—Ç—å Speaker';
            }
        }

        // View speaker
        function viewSpeaker(speakerId) {
            currentSpeakerId = speakerId;
            connectWebSocket(speakerId);

            document.getElementById('statsContainer').style.display = 'grid';
            document.getElementById('resultsSection').style.display = 'block';
            document.getElementById('logsSection').style.display = 'block';

            // Scroll to stats
            document.getElementById('statsContainer').scrollIntoView({ behavior: 'smooth' });
        }

        // Stop speaker
        async function stopSpeaker(speakerId) {
            try {
                const response = await fetch(`/api/speaker/${speakerId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    await loadSpeakers();
                } else {
                    const data = await response.json();
                    alert(`–û—à–∏–±–∫–∞: ${data.error}`);
                }
            } catch (error) {
                console.error('Failed to stop speaker:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ speaker');
            }
        }

        // Start speaker
        async function startSpeaker(speakerId) {
            try {
                const response = await fetch(`/api/speaker/${speakerId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    await loadSpeakers();
                } else {
                    const data = await response.json();
                    alert(`–û—à–∏–±–∫–∞: ${data.error}`);
                }
            } catch (error) {
                console.error('Failed to start speaker:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ speaker');
            }
        }

        // Delete speaker
        async function deleteSpeaker(speakerId) {
            if (!confirm('–£–¥–∞–ª–∏—Ç—å speaker?')) {
                return;
            }

            try {
                const response = await fetch(`/api/speaker/${speakerId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    if (currentSpeakerId === speakerId) {
                        if (ws) ws.close();
                        currentSpeakerId = null;
                        document.getElementById('statsContainer').style.display = 'none';
                        document.getElementById('resultsSection').style.display = 'none';
                        document.getElementById('logsSection').style.display = 'none';
                    }
                    await loadSpeakers();
                } else {
                    const data = await response.json();
                    alert(`–û—à–∏–±–∫–∞: ${data.error}`);
                }
            } catch (error) {
                console.error('Failed to delete speaker:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ speaker');
            }
        }

        // Update stats
        function updateStats(stats) {
            if (!stats) {
                console.warn('Stats is undefined');
                return;
            }
            document.getElementById('statSpeechCompleted').textContent = stats.speechCompleted || 0;
            document.getElementById('statSpeechFailed').textContent = stats.speechFailed || 0;
            document.getElementById('statTotalCharacters').textContent = stats.totalCharacters || 0;
            document.getElementById('statQueueLength').textContent = stats.queueLength || 0;
        }

        // Update results
        function updateResults(results) {
            if (!results) {
                console.warn('Results is undefined');
                return;
            }
            const container = document.getElementById('resultsList');
            container.innerHTML = '';

            if (results.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</p></div>';
                return;
            }

            results.forEach(result => {
                addResultElement(container, result);
            });
        }

        function addResult(result) {
            if (!result) {
                console.warn('Result is undefined');
                return;
            }
            const container = document.getElementById('resultsList');

            // Remove empty state if exists
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            addResultElement(container, result, true);
        }

        function addResultElement(container, result, prepend = false) {
            if (!result) {
                console.warn('Result is undefined in addResultElement');
                return;
            }
            const resultEl = document.createElement('div');
            resultEl.className = `result-item ${result.success ? '' : 'error'}`;

            const time = new Date(result.timestamp).toLocaleString('ru-RU');

            if (result.success) {
                resultEl.innerHTML = `
                    <div class="result-header">
                        <strong>${result.id}</strong>
                        <span class="result-time">${time}</span>
                    </div>
                    <div class="result-text">${result.text}</div>
                    <div class="audio-player">
                        <audio controls>
                            <source src="/api/speaker/${currentSpeakerId}/audio/${result.id}" type="audio/mpeg">
                            –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç.
                        </audio>
                    </div>
                    <div class="result-meta">
                        <span><strong>–ì–æ–ª–æ—Å:</strong> ${result.voice}</span>
                        <span><strong>–ú–æ–¥–µ–ª—å:</strong> ${result.model}</span>
                        <span><strong>–°–∫–æ—Ä–æ—Å—Ç—å:</strong> ${result.speed}x</span>
                        <span><strong>–†–∞–∑–º–µ—Ä:</strong> ${(result.audioSize / 1024).toFixed(1)} KB</span>
                        <span><strong>–í—Ä–µ–º—è:</strong> ${result.duration}ms</span>
                    </div>
                `;
            } else {
                resultEl.innerHTML = `
                    <div class="result-header">
                        <strong>${result.id}</strong>
                        <span class="result-time">${time}</span>
                    </div>
                    <div class="result-text">${result.text}</div>
                    <div style="color: #dc3545; margin-top: 10px;">
                        <strong>–û—à–∏–±–∫–∞:</strong> ${result.error}
                    </div>
                `;
            }

            if (prepend) {
                container.insertBefore(resultEl, container.firstChild);
            } else {
                container.appendChild(resultEl);
            }
        }

        // Update logs
        function updateLogs(logs) {
            if (!logs) {
                console.warn('Logs is undefined');
                return;
            }
            const container = document.getElementById('logsList');
            container.innerHTML = '';

            logs.forEach(log => {
                addLogElement(container, log);
            });
        }

        function addLog(log) {
            if (!log) {
                console.warn('Log is undefined');
                return;
            }
            const container = document.getElementById('logsList');
            addLogElement(container, log, true);

            // Keep only last 100 logs
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        function addLogElement(container, log, prepend = false) {
            if (!log) {
                console.warn('Log is undefined in addLogElement');
                return;
            }
            const logEl = document.createElement('div');
            const logType = getLogType(log.type);
            logEl.className = `log-item log-${logType}`;

            const time = new Date(log.timestamp).toLocaleString('ru-RU');
            logEl.textContent = `[${time}] ${log.message}`;

            if (log.data) {
                logEl.textContent += ` | ${JSON.stringify(log.data)}`;
            }

            if (prepend) {
                container.insertBefore(logEl, container.firstChild);
            } else {
                container.appendChild(logEl);
            }
        }

        function getLogType(type) {
            if (type === 'error' || type === 'speech_error') return 'error';
            if (type === 'warning') return 'warning';
            if (type === 'speech_success' || type === 'translation_received') return 'success';
            return 'info';
        }

        // Initialize
        window.addEventListener('load', () => {
            loadTranslators();
            loadSpeakers();
            updateConnectionStatus(false);
        });

        // –ü—Ä–æ—Å—Ç–∞—è –æ—á–µ—Ä–µ–¥—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –≤—Ö–æ–¥—è—â–∏—Ö –∞—É–¥–∏–æ —á–∞–Ω–∫–æ–≤ (MP3 base64) –±–µ–∑ MSE
        const speakerAudio = (() => {
            const audio = new Audio();
            audio.autoplay = true;
            let currentSpeechId = null;
            let collecting = false;
            let buffers = [];

            function start(meta) {
                // –ù–∞—á–∏–Ω–∞–µ–º —Å–±–æ—Ä —á–∞–Ω–∫–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ speechId
                currentSpeechId = meta.speechId;
                buffers = [];
                collecting = true;
            }

            function appendChunk(chunk) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–æ—Ç –∂–µ speechId
                if (!collecting || chunk.speechId !== currentSpeechId) return;
                try {
                    const binary = atob(chunk.chunkBase64);
                    const len = binary.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
                    buffers.push(bytes);
                } catch (e) {
                    console.error('Failed to decode audio chunk', e);
                }
            }

            function end(info) {
                if (!collecting || info.speechId !== currentSpeechId) return;
                collecting = false;
                // –°–∫–ª–µ–∏–≤–∞–µ–º —á–∞–Ω–∫–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–µ
                const totalLen = buffers.reduce((acc, b) => acc + b.byteLength, 0);
                const out = new Uint8Array(totalLen);
                let offset = 0;
                buffers.forEach(b => { out.set(b, offset); offset += b.byteLength; });
                const blob = new Blob([out], { type: 'audio/mpeg' });
                const url = URL.createObjectURL(blob);
                audio.src = url;
                audio.play().catch(err => console.warn('Autoplay blocked, waiting for user gesture', err));
                // –û—á–∏—Å—Ç–∏–º —Å–æ–±—Ä–∞–Ω–Ω–æ–µ
                buffers = [];
            }

            return { start, appendChunk, end };
        })();
    </script>
</body>
</html>
